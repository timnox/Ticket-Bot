require('dotenv').config();
const { Client, GatewayIntentBits, Partials, EmbedBuilder, PermissionsBitField, ButtonBuilder, ActionRowBuilder, ButtonStyle, ActivityType } = require('discord.js');
const fs = require('fs');
const path = require('path');

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.GuildMembers
  ],
  partials: [Partials.Message, Partials.Channel, Partials.Reaction]
});

client.once('ready', async () => {
  console.log(`‚úÖ Connect√© en tant que ${client.user.tag}`);
  client.user.setPresence({
    activities: [{ name: 'Ticket KMS-SHOP', type: ActivityType.Streaming, url: 'https://www.twitch.tv/SupremeB0ts' }],
    status: 'online'
  });

  const ticketChannel = await client.channels.fetch(process.env.TICKET_CHANNEL_ID);
  if (!ticketChannel) {
    console.error("‚ùå Erreur : Le salon des tickets (TICKET_CHANNEL_ID) n'existe pas !");
    return;
  }

  console.log(`üì© Envoi du message de cr√©ation de ticket dans : ${ticketChannel.name}`);

  const embed = new EmbedBuilder()
    .setTitle('üé´ **Support KMS-SHOP**')
    .setDescription('S√©lectionne une option pour cr√©er un ticket correspondant √† ton besoin.')
    .setColor('#eb37f1')
    .addFields(
      { name: 'üí∞ Achat', value: 'Cr√©er un ticket pour une demande d‚Äôachat', inline: false },
      { name: '‚ùì Question', value: 'Remplir un formulaire pour poser une question', inline: false },
      { name: 'ü§ù Partenariat', value: 'Cr√©er un ticket pour une demande de partenariat', inline: false }
    );

  const buttons = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId('create_ticket_achat').setLabel('üí∞ Achat').setStyle(ButtonStyle.Primary),
    new ButtonBuilder().setCustomId('create_ticket_question').setLabel('‚ùì Question').setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId('create_ticket_partenariat').setLabel('ü§ù Partenariat').setStyle(ButtonStyle.Success)
  );

  await ticketChannel.send({ embeds: [embed], components: [buttons] });
});

client.on('interactionCreate', async interaction => {
  if (interaction.isButton() && interaction.customId.startsWith('create_ticket')) {
    let ticketType = interaction.customId.split('_')[2];
    console.log(`üõ† Cr√©ation du ticket demand√©e par ${interaction.user.username} - Type: ${ticketType}`);

    const channelName = `ticket-${interaction.user.username}-${ticketType}`;
    
    try {
      const channel = await interaction.guild.channels.create({
        name: channelName,
        type: 0,
        parent: process.env.TICKET_CATEGORY_ID,
        permissionOverwrites: [
          { id: interaction.guild.id, deny: [PermissionsBitField.Flags.ViewChannel] },
          { id: interaction.user.id, allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages] },
        ],
      });

      const embed = new EmbedBuilder()
        .setTitle(`üé´ Ticket ${ticketType} cr√©√©`)
        .setDescription(`Bonjour ${interaction.user}, explique ici ton probl√®me et un membre du support te r√©pondra.`)
        .setColor('#eb37f1');

      const button = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('close_ticket').setLabel('‚ùå Fermer le ticket').setStyle(ButtonStyle.Danger)
      );

      await channel.send({ embeds: [embed], components: [button] });

      await interaction.reply({ content: `üé´ Ton ticket a √©t√© cr√©√© ici : <#${channel.id}>`, ephemeral: true });
    } catch (err) {
      console.error("‚ùå Erreur lors de la cr√©ation du ticket :", err);
      await interaction.reply({ content: "‚ùå Impossible de cr√©er le ticket.", ephemeral: true });
    }
  }

  if (interaction.isButton() && interaction.customId === 'close_ticket') {
    console.log(`üîí Fermeture du ticket demand√©e : ${interaction.channel.name}`);

    const embed = new EmbedBuilder()
      .setTitle('‚ö†Ô∏è Confirmation')
      .setDescription('Es-tu s√ªr de vouloir fermer ce ticket ?')
      .setColor('#eb37f1');

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder().setCustomId('close_ticket_confirmed').setLabel('‚úÖ Oui, fermer le ticket').setStyle(ButtonStyle.Danger),
      new ButtonBuilder().setCustomId('close_ticket_cancel').setLabel('‚ùå Annuler').setStyle(ButtonStyle.Secondary)
    );

    await interaction.reply({ embeds: [embed], components: [buttons], ephemeral: true });
  }

  if (interaction.isButton() && interaction.customId === 'close_ticket_confirmed') {
    console.log(`‚úÖ Ticket ferm√© : ${interaction.channel.name}`);

    const logChannel = await interaction.guild.channels.fetch(process.env.LOG_CHANNEL_ID);
    if (!logChannel) {
      console.error("‚ùå Erreur : Le salon des logs n'existe pas !");
      return interaction.reply({ content: "‚ùå Erreur lors de la fermeture du ticket.", ephemeral: true });
    }

    const transcriptDir = path.join(__dirname, 'transcripts');
    const transcriptPath = path.join(transcriptDir, `${interaction.channel.name}.txt`);

    // V√©rifie que le dossier "transcripts" existe, sinon le cr√©e
    if (!fs.existsSync(transcriptDir)) {
        fs.mkdirSync(transcriptDir);
    }

    // V√©rifie que le fichier existe et le cr√©e avec du contenu s'il est absent
    if (!fs.existsSync(transcriptPath)) {
        fs.writeFileSync(transcriptPath, `Transcript du ticket ${interaction.channel.name} :\n\n`);
        console.log(`‚úÖ Fichier transcript g√©n√©r√© : ${transcriptPath}`);
    }

    const transcriptEmbed = new EmbedBuilder()
      .setTitle('üìú Ticket ferm√©')
      .setDescription(`Ticket **${interaction.channel.name}** ferm√©.`)
      .setColor('#eb37f1');

    await logChannel.send({ embeds: [transcriptEmbed], files: [transcriptPath] });

    await interaction.channel.delete();
  }
});

client.login(process.env.TOKEN);